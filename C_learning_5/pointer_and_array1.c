#include<stdio.h>
#define STARS "******************************\n"
int main()
{
	int a[3][4] =
	{
		{0, 1, 2, 3},
		{4, 5, 6, 7},
		{8, 9, 10, 11}
	};
	printf(STARS);
	printf("a=%p\n", a);
	printf("a+1=%p\n", a + 1);
	printf("a+2=%p\n", a + 2);
	//a是数组名，是该数组的首地址，
	//指向该数组的第一个存储单元（一个一维数组）						a类型为int(*)[4]
	//因为a+1 会跳到第二个数组，地址加上16B
	printf(STARS);
	printf("*a=%p\n", *a);
	printf("*a+1=%p\n", *a + 1);
	printf("*(a+1)=%p\n", *(a + 1));
	//*a==a[0]==&a[0][0]---> *
	//*a+1,地址会偏移4B，即指向下一个数据
	//*(a+1),地址会偏移16B，即指向下一个一维数组
	printf(STARS);
	printf("&a=%p\n", &a);
	printf("&a+1=%p\n", &a + 1);
	printf("&(a+1)=ERORR");
	// printf("&(a+1)=%p\n", &(a + 1));这种写法错误
	//a是指针常量，不能被改变,即 int a[]==int * const a
	//&a指向整个二维数组，是取这个二维数组的地址						&a类型为 int(*)[3][4]
	//&a+1 地址偏移了48B，跳过了整个二维数组
	printf("&a[0]=%p\n", &a[0]);
	printf("&a[0]+1=%p\n", &a[0] + 1);
	printf("&a[0]+1=%p\n", &a[0]);
	printf("&(a[0]+1)=ERORR");
	//&a[0]指向第一个数组，是取第一个数组的地址						&a[0]类型为 int(*)[4]
	//&a[0]+1 地址偏移了16B，跳过了第一个一维数组
	printf(STARS);
	printf("a[0]=%p\n", a[0]);
	printf("a[0]+1=%p\n", a[0] + 1);
	printf("&a[0][0]%p\n", &a[0][0]);
	//a[0]是第一个数组的数组名，是第一个数组的首地址，
	//指向第一个存储单元（一个数据a[0][0]）							a[0]类型为 int*
	//a[0]+1,指向了第二个存储单元，地址偏移了4B
	//&a[0][0],是指向a[0][0]的指针，								&a[0][0]类型为 int*
	printf(STARS);
	//访问数组中的元素
	//1.下标法
	printf("a[i][j]\n");
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
			printf("%5d", a[i][j]);

		printf("\n");

	}
	printf(STARS);
	//2.指针法
	printf("1:*(a[i]+j)\n");
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
			printf("%5d", *(a[i] + j));
		printf("\n");
	}
	printf(STARS);
	printf("2:*(*(a+i)+j)\n");
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
			printf("%5d", *(*(a + i) + j));
		printf("\n");
	}
	printf(STARS);


	return 0;
}
/*
经过上面的分析，对于二维数组 a[3][4]有如下结论：
***************************************************************************************************
表达式					数据类型				指向

a==&a[0]				int(*)[4]			均指向第一个一维数组
a[0]==&a[0][0]			int*				均指向第一个一维数组的第一个单元
&a						int(*)[3][4]		指向整个二维数组
*(a+i)=a[i]==&a[i][0]   int*                指向数组i的第一个存储单元
***************************************************************************************************
运算				意义
a+1				a		指向第一个一维数组								所以a+1地址偏移4x4=16B
*a+1            *a		指向第一个数组的第一个单元							所以*a+1地址偏移4B
*(a+1)          a+1		指向下一个数组，*a==a[0]---->*(a+1)==a[1]			所以a+1地址偏移4x4=16B
&a+1			&a		指向整个二维数组，								所以&a+1地址偏移4x4x3=48B
&(a+1)					数组名a是指针常量，不能更改了，此种写法错误
&a[0]+1			&a[0]	指向第一个数组，&a[0]+1---->&a[1],指向下一个数组   所以地址偏移4x4=16B
&(a[0]+1）				此种写法错误
a[0]+1          a[0]	指向第一个数组的首地址a[0][0]，所以a[0]+1指向下一个数据a[0][1]，地址偏移4B
***************************************************************************************************
注意：
1.首地址：一段存储空间中的第一个存储单元的地址
  例如 int a[3][4]
  a为二维数组的首地址，这个二维数组的第一个存储单元是一个一维数组
  a[0]为第一个一维数组的首地址，这个一维数组的第一个存储单元是一个int型数据

2.分析指针：关键不在指针的值，而实指针的类型，指向
3.*a==a[0]==&a[0][0]
***************************************************************************************************
访问数组元素
1.下标法
2.指针法
*(a[i]+j)
*(*(a+i)+j)
*/